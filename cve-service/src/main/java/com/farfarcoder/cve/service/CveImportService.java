package com.farfarcoder.cve.service;

import com.farfarcoder.cve.domain.*;
import com.farfarcoder.cve.repository.CveItemRepository;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.stream.Stream;

@Service
@RequiredArgsConstructor
@Slf4j
public class CveImportService {

    private final CveItemRepository cveItemRepository;
    private final ObjectMapper objectMapper;

    public int importCveFromFolder(String folderPath, int startYear, int endYear) {
        log.info("Starting CVE import from {} for years {}-{}", folderPath, startYear, endYear);
        int count = 0;

        for (int year = startYear; year <= endYear; year++) {
            Path yearPath = Paths.get(folderPath, String.valueOf(year));
            if (!Files.exists(yearPath)) {
                log.warn("Year folder not found: {}", yearPath);
                continue;
            }

            try (Stream<Path> paths = Files.walk(yearPath)) {
                count += paths.filter(Files::isRegularFile)
                        .filter(p -> p.toString().endsWith(".json"))
                        .mapToInt(this::processCveFile)
                        .sum();
            } catch (IOException e) {
                log.error("Error walking through directory: {}", yearPath, e);
            }
        }
        log.info("Imported {} CVE items.", count);
        return count;
    }

    private int processCveFile(Path file) {
        try {
            JsonNode root = objectMapper.readTree(file.toFile());

            // 1. Extract CVE ID
            String cveId = root.path("cveMetadata").path("cveId").asText();
            if (cveId == null || cveId.isEmpty()) {
                cveId = root.path("cve").path("CVE_data_meta").path("ID").asText();
            }

            if (cveId == null || cveId.isEmpty()) {
                log.debug("No CVE ID found in file: {}", file);
                return 0;
            }

            if (cveItemRepository.existsByCveId(cveId)) {
                log.debug("CVE already exists: {}", cveId);
                return 0;
            }

            CveItem item = new CveItem();
            item.setCveId(cveId);
            item.setRawJson(root.toString());

            // 2. Extract Metadata
            JsonNode metadata = root.path("cveMetadata");
            item.setState(metadata.path("state").asText("PUBLISHED"));
            item.setAssignerOrgId(metadata.path("assignerOrgId").asText(null));
            item.setAssignerShortName(metadata.path("assignerShortName").asText(null));
            item.setDatePublished(parseDate(metadata.path("datePublished").asText(null)));
            item.setDateUpdated(parseDate(metadata.path("dateUpdated").asText(null)));
            item.setDateReserved(parseDate(metadata.path("dateReserved").asText(null)));

            // 3. Extract Containers (CNA)
            JsonNode cna = root.path("containers").path("cna");
            item.setTitle(cna.path("title").asText(null));

            // Description
            JsonNode descriptions = cna.path("descriptions");
            if (descriptions.isArray() && descriptions.size() > 0) {
                String desc = descriptions.get(0).path("value").asText();
                item.setDescription(desc.length() > 4000 ? desc.substring(0, 4000) : desc);
            } else {
                // Fallback legacy
                JsonNode legacyDesc = root.path("cve").path("description").path("description_data");
                if (legacyDesc.isArray() && legacyDesc.size() > 0) {
                    String desc = legacyDesc.get(0).path("value").asText();
                    item.setDescription(desc.length() > 4000 ? desc.substring(0, 4000) : desc);
                } else {
                    item.setDescription("No description available");
                }
            }

            // 4. Extract Metrics (CVSS)
            extractMetrics(cna, item);

            // 5. Extract References
            extractReferences(cna, item);

            // 6. Extract Affected Products
            extractAffectedProducts(cna, item);

            // 7. Extract Problem Types
            extractProblemTypes(cna, item);

            // 8. Extract Credits
            extractCredits(cna, item);

            cveItemRepository.save(item);
            log.debug("Imported CVE: {}", cveId);
            return 1;

        } catch (Exception e) {
            log.error("Failed to parse CVE file: {}", file, e);
            return 0;
        }
    }

    private void extractMetrics(JsonNode cna, CveItem item) {
        JsonNode metrics = cna.path("metrics");
        if (metrics.isArray() && metrics.size() > 0) {
            JsonNode metric = metrics.get(0);
            JsonNode cvssV3_1 = metric.path("cvssV3_1");
            JsonNode cvssV3_0 = metric.path("cvssV3_0");
            JsonNode cvss = !cvssV3_1.isMissingNode() ? cvssV3_1 : cvssV3_0;

            if (!cvss.isMissingNode()) {
                item.setCvssVersion(cvss.path("version").asText(null));
                item.setCvssVector(cvss.path("vectorString").asText(null));
                item.setCvssScore(java.math.BigDecimal.valueOf(cvss.path("baseScore").asDouble(0.0)));
                item.setCvssSeverity(cvss.path("baseSeverity").asText(null));
            }
        }
    }

    private void extractReferences(JsonNode cna, CveItem item) {
        JsonNode references = cna.path("references");
        if (references.isArray()) {
            for (JsonNode ref : references) {
                CveReference reference = new CveReference();
                reference.setUrl(ref.path("url").asText());
                reference.setReferenceName(ref.path("name").asText(null));
                reference.setTags(ref.path("tags").toString());
                reference.setCveItem(item);
                item.getReferences().add(reference);
            }
        }
    }

    private void extractAffectedProducts(JsonNode cna, CveItem item) {
        JsonNode affected = cna.path("affected");
        if (affected.isArray()) {
            for (JsonNode aff : affected) {
                CveAffectedProduct product = new CveAffectedProduct();
                product.setVendor(aff.path("vendor").asText("Unknown"));
                product.setProduct(aff.path("product").asText("Unknown"));
                product.setVersionsJson(aff.path("versions").toString());

                // Simple summary
                if (aff.path("versions").isArray() && aff.path("versions").size() > 0) {
                    product.setVersionSummary(aff.path("versions").get(0).path("version").asText(""));
                }

                product.setCveItem(item);
                item.getAffectedProducts().add(product);

                // Set primary vendor/product for CveItem (first one found)
                if (item.getPrimaryVendor() == null) {
                    item.setPrimaryVendor(product.getVendor());
                    item.setPrimaryProduct(product.getProduct());
                }
            }
        }
    }

    private void extractProblemTypes(JsonNode cna, CveItem item) {
        JsonNode problemTypes = cna.path("problemTypes");
        if (problemTypes.isArray()) {
            for (JsonNode pt : problemTypes) {
                JsonNode descriptions = pt.path("descriptions");
                if (descriptions.isArray()) {
                    for (JsonNode desc : descriptions) {
                        CveProblemType problem = new CveProblemType();
                        problem.setDescription(desc.path("description").asText());
                        problem.setCweId(desc.path("cweId").asText(null));
                        problem.setProblemType(desc.path("type").asText(null));
                        problem.setCveItem(item);
                        item.getProblemTypes().add(problem);
                    }
                }
            }
        }
    }

    private void extractCredits(JsonNode cna, CveItem item) {
        JsonNode credits = cna.path("credits");
        if (credits.isArray()) {
            for (JsonNode cr : credits) {
                CveCredit credit = new CveCredit();
                credit.setCreditedPerson(cr.path("value").asText());
                credit.setLang(cr.path("lang").asText("en"));
                credit.setCveItem(item);
                item.getCredits().add(credit);
            }
        }
    }

    private java.time.LocalDateTime parseDate(String dateStr) {
        if (dateStr == null || dateStr.isEmpty())
            return null;
        try {
            // Try ISO_DATE_TIME first (e.g., 2020-12-08T15:30:16.835255Z)
            return java.time.LocalDateTime.parse(dateStr, java.time.format.DateTimeFormatter.ISO_DATE_TIME);
        } catch (Exception e) {
            try {
                // Try simpler format if needed, or just return null/log warning
                // Removing 'Z' if present for simple LocalDatetime parsing if ISO fails
                if (dateStr.endsWith("Z")) {
                    return java.time.LocalDateTime.parse(dateStr.substring(0, dateStr.length() - 1));
                }
                return java.time.LocalDateTime.parse(dateStr);
            } catch (Exception ex) {
                log.warn("Failed to parse date: {}", dateStr);
                return null;
            }
        }
    }
}
