package com.farfarcoder.cve.service;

import com.farfarcoder.cve.domain.CveItem;
import com.farfarcoder.cve.repository.CveItemRepository;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.stream.Stream;

@Service
@RequiredArgsConstructor
@Slf4j
public class CveImportService {

    private final CveItemRepository cveItemRepository;
    private final ObjectMapper objectMapper;

    @Transactional
    public int importCveFromFolder(String folderPath, int startYear, int endYear) {
        log.info("Starting CVE import from {} for years {}-{}", folderPath, startYear, endYear);
        int count = 0;

        for (int year = startYear; year <= endYear; year++) {
            Path yearPath = Paths.get(folderPath, String.valueOf(year));
            if (!Files.exists(yearPath)) {
                log.warn("Year folder not found: {}", yearPath);
                continue;
            }

            try (Stream<Path> paths = Files.walk(yearPath)) {
                count += paths.filter(Files::isRegularFile)
                        .filter(p -> p.toString().endsWith(".json"))
                        .mapToInt(this::processCveFile)
                        .sum();
            } catch (IOException e) {
                log.error("Error walking through directory: {}", yearPath, e);
            }
        }
        log.info("Imported {} CVE items.", count);
        return count;
    }

    private int processCveFile(Path file) {
        try {
            JsonNode root = objectMapper.readTree(file.toFile());
            // This parsing logic depends heavily on the NVD CVE JSON format (e.g., v3.1 or
            // v4.0 or v5.0)
            // Assuming a simplified structure or NVD JSON 1.1 structure for this demo

            String cveId = root.path("cve").path("CVE_data_meta").path("ID").asText();
            if (cveId == null || cveId.isEmpty()) {
                // Try NVD 2.0/5.0 structure
                cveId = root.path("cveMetadata").path("cveId").asText();
            }

            if (cveId == null || cveId.isEmpty() || cveItemRepository.existsByCveId(cveId)) {
                return 0;
            }

            CveItem item = new CveItem();
            item.setCveId(cveId);

            // Extract description
            JsonNode descriptions = root.path("cve").path("description").path("description_data");
            if (descriptions.isArray() && descriptions.size() > 0) {
                item.setDescription(descriptions.get(0).path("value").asText());
            } else {
                // NVD 5.0
                JsonNode desc5 = root.path("containers").path("cna").path("descriptions");
                if (desc5.isArray() && desc5.size() > 0) {
                    item.setDescription(desc5.get(0).path("value").asText());
                }
            }

            // Extract Severity (V3)
            JsonNode impact = root.path("impact").path("baseMetricV3");
            if (!impact.isMissingNode()) {
                item.setBaseScore(impact.path("cvssV3").path("baseScore").asDouble());
                item.setSeverity(impact.path("cvssV3").path("baseSeverity").asText());
            } else {
                // NVD 5.0 metrics
                JsonNode metrics = root.path("containers").path("cna").path("metrics");
                if (metrics.isArray() && metrics.size() > 0) {
                    JsonNode cvssV3_1 = metrics.get(0).path("cvssV3_1");
                    if (!cvssV3_1.isMissingNode()) {
                        item.setBaseScore(cvssV3_1.path("baseScore").asDouble());
                        item.setSeverity(cvssV3_1.path("baseSeverity").asText());
                    }
                }
            }

            // Extract Product (Simplified - just taking the first one found)
            // This is complex in real world due to CPE structures
            // For demo, we assume we can find a vendor/product name
            // NVD 1.1
            JsonNode affects = root.path("cve").path("affects").path("vendor").path("vendor_data");
            if (affects.isArray() && affects.size() > 0) {
                JsonNode productData = affects.get(0).path("product").path("product_data");
                if (productData.isArray() && productData.size() > 0) {
                    item.setProductName(productData.get(0).path("product_name").asText());
                }
            }

            cveItemRepository.save(item);
            return 1;

        } catch (Exception e) {
            log.error("Failed to parse CVE file: {}", file, e);
            return 0;
        }
    }
}
